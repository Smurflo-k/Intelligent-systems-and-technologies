# -*- coding: utf-8 -*-
"""ИИ_лабы_2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kcxyunv-Ogw56GgJqNTXV9RO3ykaldEZ

Установка библиотек
"""

!pip install vk_api
import vk_api

"""Получение сессии"""

token = ' '

session = vk_api.VkApi(token=token)
vk = session.get_api()

"""Создание графа друзей пользователя с идентификатором 240822739 и соединяет его с другими членами группы, указанными в списке member_ids"""

import networkx as nx
G = nx.Graph()
member_ids = [240822739, 61265674, 162541236]  #Пользователи Влад, Фаиль, Ваня
for member in member_ids:
    friends = vk.friends.get(user_id=240822739)
    result = [G.add_edge(member, friend) for friend in friends['items']]

import matplotlib.pyplot as plt
nx.draw(G, with_labels=True, node_color='lightblue', font_size=10, font_weight='bold')
plt.show()

import time
def get_friends(vk, user_id):
    try:
        friends = vk.friends.get(user_id=user_id)
        return [friend for friend in friends['items']]
    except Exception as e:
        print(e)
        return []


G1 = nx.Graph()
member_ids = [240822739, 61265674, 162541236]
for member in member_ids:
    G1.add_node(member)
    friends = get_friends(vk, member)

    for friend in friends:
        print(friend)
        G1.add_node(friend)
        G1.add_edge(member, friend)
        fofs = get_friends(vk, user_id=friend)[:50]
        for fof in fofs:
            G1.add_node(fof)
            G1.add_edge(friend, fof)

    time.sleep(1)

"""Количество ребер"""

G1.number_of_edges()

G1.number_of_nodes()

"""Центральность по посредничеству


"""

betweenness = nx.betweenness_centrality(G1)
for node, value in betweenness.items():
    print(f"Узел {node}: {value}")

"""Центральность по близости"""

closeness = nx.closeness_centrality(G1)
for node, value in closeness.items():
    print(f"Узел {node}: {value}")

"""Центральность по собственному значению"""

eigenvector = nx.eigenvector_centrality(G1)
for node, value in eigenvector.items():
    print(f"Узел {node}: {value}")

nx.draw(G1, with_labels=True, node_color='lightblue', font_size=10, font_weight='bold')
plt.show()

"""Максимальное значение центральости по посреднечеству"""

max_key = max(betweenness, key=betweenness.get)
print(f"ID узла: {max_key}, Значение: {betweenness[max_key]}")
sorted_betweenness = sorted(betweenness.items(), key=lambda x: x[1], reverse=True)

# Проверяем, достаточно ли элементов для 2-го и 3-го места
if len(sorted_betweenness) >= 3:
    max_key = sorted_betweenness[0]  # 1 место
    second_key = sorted_betweenness[1]  # 2 место
    third_key = sorted_betweenness[2]  # 3 место

    print(f"1 место - ID узла: {max_key[0]}, Значение: {max_key[1]}")
    print(f"2 место - ID узла: {second_key[0]}, Значение: {second_key[1]}")
    print(f"3 место - ID узла: {third_key[0]}, Значение: {third_key[1]}")
else:
    print("Недостаточно элементов для определения 2-го и 3-го места.")

"""Максимальное значение центральность по близости"""

max_key_1 = max(closeness, key=closeness.get)
print(f"ID узла: {max_key_1}, Значение: {closeness[max_key_1]}")
# Сортировка словаря closeness по значениям в порядке убывания
sorted_closeness = sorted(closeness.items(), key=lambda x: x[1], reverse=True)

# Проверяем, достаточно ли элементов
if len(sorted_closeness) >= 3:
    max_key_1 = sorted_closeness[0]  # 1 место
    second_key = sorted_closeness[1]  # 2 место
    third_key = sorted_closeness[2]  # 3 место

    print(f"1 место - ID узла: {max_key_1[0]}, Значение: {max_key_1[1]}")
    print(f"2 место - ID узла: {second_key[0]}, Значение: {second_key[1]}")
    print(f"3 место - ID узла: {third_key[0]}, Значение: {third_key[1]}")
else:
    print("Недостаточно элементов для определения 2-го и 3-го места.")

"""Максимальное значение центральность по собственному значению"""

max_key_2 = max(eigenvector, key=eigenvector.get)
print(f"ID узла: {max_key_2}, Значение: {eigenvector[max_key_2]}")
# Сортировка словаря eigenvector по значениям в порядке убывания
sorted_eigenvector = sorted(eigenvector.items(), key=lambda x: x[1], reverse=True)

# Проверяем, достаточно ли элементов
if len(sorted_eigenvector) >= 3:
    max_key_2 = sorted_eigenvector[0]  # 1 место
    second_key = sorted_eigenvector[1]  # 2 место
    third_key = sorted_eigenvector[2]  # 3 место

    print(f"1 место - ID узла: {max_key_2[0]}, Значение: {max_key_2[1]}")
    print(f"2 место - ID узла: {second_key[0]}, Значение: {second_key[1]}")
    print(f"3 место - ID узла: {third_key[0]}, Значение: {third_key[1]}")
else:
    print("Недостаточно элементов для определения 2-го и 3-го места.")